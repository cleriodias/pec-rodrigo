name: Deploy to Azure Web App

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  APP_ENV: production
  APP_DEBUG: 'false'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, bcmath, openssl, pdo_mysql, tokenizer, xml, ctype, json

      - name: Install Composer dependencies
        run: composer install --no-dev --prefer-dist --optimize-autoloader

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Node packages
        run: NODE_ENV=development npm ci

      - name: Build frontend assets
        run: NODE_ENV=production npm run build

      - name: Prepare deployment package (Linux App Service root)
        run: |
          rm -rf artifacts
          mkdir -p artifacts/staging
          rsync -a --exclude node_modules --exclude storage/logs --exclude vendor/bin --exclude artifacts --exclude .git --exclude .github --exclude .env ./ artifacts/staging/app/
          rsync -a public/ artifacts/staging/
          cp public/index.php artifacts/staging/index.php
          rm -f artifacts/staging/hostingstart.html
          sed -i "s#__DIR__.'/../storage#__DIR__.'/app/storage#g" artifacts/staging/index.php
          sed -i "s#__DIR__.'/../vendor/#__DIR__.'/app/vendor/#g" artifacts/staging/index.php
          sed -i "s#__DIR__.'/../bootstrap/#__DIR__.'/app/bootstrap/#g" artifacts/staging/index.php
          rm -rf artifacts/staging/storage
          ln -s app/storage/app/public artifacts/staging/storage
          (cd artifacts/staging && zip -r ../app.zip .)

      - name: Debug package contents
        run: |
          ls -la artifacts/staging
          ls -la artifacts/staging/index.php
          ls -la artifacts/staging/storage
          unzip -l artifacts/app.zip | head -n 50

      - name: Parse publish profile
        id: publish-profile
        env:
          PUBLISH_PROFILE: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        run: |
          python - <<'PY'
          import os
          import xml.etree.ElementTree as ET

          data = os.environ.get("PUBLISH_PROFILE", "")
          if not data.strip():
              raise SystemExit("Missing publish profile secret.")

          root = ET.fromstring(data)
          profiles = root.findall(".//publishProfile")
          if not profiles:
              raise SystemExit("No publishProfile found.")

          prof = None
          for p in profiles:
              if p.get("publishMethod") == "ZipDeploy":
                  prof = p
                  break
          if prof is None:
              prof = profiles[0]

          publish_url = prof.get("publishUrl")
          user = prof.get("userName")
          pwd = prof.get("userPWD")
          if not publish_url or not user or not pwd:
              raise SystemExit("publish profile missing required fields.")

          publish_url = publish_url.replace("https://", "").replace("http://", "")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
              f.write(f"publish_url={publish_url}\n")
              f.write(f"user={user}\n")
              f.write(f"password={pwd}\n")
          PY

      - name: Mask publish credentials
        run: |
          echo "::add-mask::${{ steps.publish-profile.outputs.user }}"
          echo "::add-mask::${{ steps.publish-profile.outputs.password }}"

      - name: Deploy via Kudu ZipDeploy (clean)
        env:
          PUBLISH_URL: ${{ steps.publish-profile.outputs.publish_url }}
          PUBLISH_USER: ${{ steps.publish-profile.outputs.user }}
          PUBLISH_PASSWORD: ${{ steps.publish-profile.outputs.password }}
        run: |
          set -euo pipefail
          response_headers=$(mktemp)
          curl -f -sS -u "$PUBLISH_USER:$PUBLISH_PASSWORD" \
            -D "$response_headers" \
            -X POST -T artifacts/app.zip \
            "https://$PUBLISH_URL/api/zipdeploy?isAsync=true&clean=true" \
            -o /dev/null
          deploy_url=$(grep -i "^Location:" "$response_headers" | awk '{print $2}' | tr -d '\r')
          if [ -z "$deploy_url" ]; then
            echo "Nao foi possivel obter o Location do deploy."
            cat "$response_headers"
            exit 1
          fi
          echo "Deploy URL: $deploy_url"
          for i in {1..60}; do
            status_json=$(curl -f -sS -u "$PUBLISH_USER:$PUBLISH_PASSWORD" "$deploy_url")
            status=$(python -c "import json,sys; print(json.load(sys.stdin).get('status'))" <<< "$status_json")
            if [ "$status" = "4" ]; then
              echo "Deploy concluido."
              exit 0
            fi
            if [ "$status" = "3" ]; then
              echo "Deploy falhou."
              echo "$status_json"
              log_url=$(python -c "import json,sys; print(json.load(sys.stdin).get('log_url'))" <<< "$status_json")
              if [ -n "$log_url" ] && [ "$log_url" != "None" ]; then
                echo "Logs do deploy:"
                curl -f -sS -u "$PUBLISH_USER:$PUBLISH_PASSWORD" "$log_url"
              fi
              exit 1
            fi
            sleep 5
          done
          echo "Timeout aguardando deploy."
          echo "$status_json"
          exit 1

      - name: Check WEBSITE_RUN_FROM_PACKAGE
        env:
          PUBLISH_URL: ${{ steps.publish-profile.outputs.publish_url }}
          PUBLISH_USER: ${{ steps.publish-profile.outputs.user }}
          PUBLISH_PASSWORD: ${{ steps.publish-profile.outputs.password }}
        run: |
          set -euo pipefail
          response_headers=$(mktemp)
          settings_json=$(curl -sS -u "$PUBLISH_USER:$PUBLISH_PASSWORD" \
            -D "$response_headers" \
            -H "Accept: application/json" \
            "https://$PUBLISH_URL/api/settings")
          echo "Status da API /api/settings:"
          head -n 5 "$response_headers"
          python - <<'PY'
          import json
          import sys

          raw = sys.stdin.read().strip()
          if not raw:
              print("Resposta vazia de /api/settings.")
              sys.exit(0)
          try:
              data = json.loads(raw)
          except json.JSONDecodeError:
              print("Resposta nao JSON de /api/settings:")
              print(raw[:500])
              sys.exit(0)
          val = data.get("WEBSITE_RUN_FROM_PACKAGE", "")
          if not val:
              print("WEBSITE_RUN_FROM_PACKAGE: empty")
          elif val == "1":
              print("WEBSITE_RUN_FROM_PACKAGE: 1")
          elif val.lower().startswith("http"):
              print("WEBSITE_RUN_FROM_PACKAGE: url")
          else:
              print("WEBSITE_RUN_FROM_PACKAGE: set")
          PY
          <<< "$settings_json"

      - name: Verify wwwroot contents
        env:
          PUBLISH_URL: ${{ steps.publish-profile.outputs.publish_url }}
          PUBLISH_USER: ${{ steps.publish-profile.outputs.user }}
          PUBLISH_PASSWORD: ${{ steps.publish-profile.outputs.password }}
        run: |
          set -euo pipefail
          response_headers=$(mktemp)
          items_json=$(curl -sS -u "$PUBLISH_USER:$PUBLISH_PASSWORD" \
            -D "$response_headers" \
            -H "Accept: application/json" \
            "https://$PUBLISH_URL/api/vfs/site/wwwroot/")
          echo "Status da API /api/vfs/site/wwwroot/:"
          head -n 5 "$response_headers"
          python - <<'PY'
          import json
          import sys

          raw = sys.stdin.read().strip()
          if not raw:
              print("Resposta vazia de /api/vfs/site/wwwroot/.")
              sys.exit(0)
          try:
              data = json.loads(raw)
          except json.JSONDecodeError:
              print("Resposta nao JSON de /api/vfs/site/wwwroot/:")
              print(raw[:500])
              sys.exit(0)
          names = sorted([
              item.get("name")
              for item in data
              if isinstance(item, dict) and item.get("name")
          ])
          print("wwwroot:", ", ".join(names))
          if "index.php" not in names:
              print("index.php not found in wwwroot.")
              sys.exit(1)
          PY
          <<< "$items_json"
